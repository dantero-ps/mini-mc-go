---
phase: 01-3d-terrain-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/world/noise.go
  - internal/world/density.go
  - internal/world/generator.go
  - internal/world/chunk_streamer.go
  - internal/world/world.go
autonomous: true

must_haves:
  truths:
    - "World generates using 3D density functions instead of heightmap"
    - "Terrain includes natural overhangs and floating formations"
    - "Underground empty spaces exist (pre-cave system)"
    - "Generation remains deterministic from same seed"
  artifacts:
    - path: "internal/world/noise.go"
      provides: "3D value noise with trilinear interpolation"
      contains: "func valueNoise3D"
    - path: "internal/world/density.go"
      provides: "DensityGenerator with height gradient"
      contains: "type DensityGenerator struct"
      exports: ["NewDensityGenerator"]
    - path: "internal/world/generator.go"
      provides: "TerrainGenerator interface (unchanged contract)"
      contains: "type TerrainGenerator interface"
    - path: "internal/world/chunk_streamer.go"
      provides: "Column height estimation for 3D density terrain"
      contains: "HeightAt"
    - path: "internal/world/world.go"
      provides: "World using DensityGenerator"
      contains: "NewDensityGenerator"
  key_links:
    - from: "internal/world/density.go"
      to: "internal/world/noise.go"
      via: "octaveNoise3D call in computeDensity"
      pattern: "octaveNoise3D"
    - from: "internal/world/world.go"
      to: "internal/world/density.go"
      via: "NewDensityGenerator replaces NewGenerator"
      pattern: "NewDensityGenerator"
    - from: "internal/world/chunk_streamer.go"
      to: "internal/world/generator.go"
      via: "HeightAt interface method for column height"
      pattern: "gen\\.HeightAt"
---

<objective>
Implement 3D density-based terrain generation to replace the current 2D heightmap system.

Purpose: Enable overhangs, floating formations, and underground empty spaces by switching from 2D heightmap sampling to 3D density field evaluation. This is the foundational change that unlocks caves (Phase 3), biome-specific terrain shapes (Phase 2), and vertical terrain variety.

Output: Working 3D terrain generator that produces varied terrain with overhangs and underground voids, fully wired into the existing chunk streaming system, maintaining determinism.
</objective>

<execution_context>
@/Users/furkandogan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/furkandogan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-3d-terrain-foundation/01-RESEARCH.md

# Source files to modify
@internal/world/noise.go
@internal/world/generator.go
@internal/world/chunk_streamer.go
@internal/world/world.go
@internal/world/chunk.go
@internal/world/block.go
@internal/game/session.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend noise.go with 3D value noise functions</name>
  <files>internal/world/noise.go</files>
  <action>
Add 3D noise functions to the existing noise.go file, preserving all existing 2D functions (they are still used by FlatGenerator tests and may be useful later).

Add the following functions:

1. `hash3(x, y, z int64, seed int64) uint64` — Extend the existing SplitMix64-style hash to 3D. Use the same mixing constants as `hash2` but incorporate Y coordinate. Use bit shifts to ensure different coordinate combinations produce different hashes:
   ```
   v := uint64(x)*0x9E3779B97F4A7C15 + uint64(y)*0x517CC1B727220A95 + uint64(z)*0x6C62272E07BB0142 + uint64(seed)
   ```
   Then apply the same SplitMix64 mixing steps as hash2. Using separate multipliers per axis (golden ratio variants) gives much better distribution than the current `<<1`/`<<2` bit shifts suggested in research (which cause collisions for coordinates like (1,0,0) vs (0,0,1)).

2. `latticeValue3D(x, y, z int64, seed int64) float64` — Same pattern as `latticeValue` but using `hash3`. Returns [0,1].

3. `valueNoise3D(x, y, z float64, seed int64) float64` — 3D value noise with trilinear interpolation. Follow the canonical order:
   - Floor to get 8 lattice corners (x0,y0,z0 through x1,y1,z1)
   - Compute fade weights fx, fy, fz using existing `fade()` function
   - Get 8 corner values via `latticeValue3D`
   - Trilinear interpolation: lerp along X (4 results), then Y (2 results), then Z (1 result)
   - Returns [0,1]

4. `octaveNoise3D(x, y, z float64, seed int64, octaves int, persistence, lacunarity float64) float64` — Same pattern as `octaveNoise2D` but using `valueNoise3D`. Use `seed+int64(i*131)` per octave offset (matching existing 2D pattern). Returns [0,1].

IMPORTANT: Use `float64` for ALL noise calculations (determinism). Use `int64` for ALL hash inputs (determinism). Reuse existing `fade()` and `lerp()` functions. Do NOT modify existing 2D functions.
  </action>
  <verify>
Run `go build ./internal/world/` to verify compilation. Run `go vet ./internal/world/` for correctness.
  </verify>
  <done>noise.go contains hash3, latticeValue3D, valueNoise3D, octaveNoise3D functions. All existing 2D functions unchanged. Package compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create DensityGenerator and wire into world system</name>
  <files>internal/world/density.go, internal/world/generator.go, internal/world/chunk_streamer.go, internal/world/world.go</files>
  <action>
**Step A: Create `internal/world/density.go`**

Create a new file implementing `DensityGenerator` that satisfies the `TerrainGenerator` interface.

DensityGenerator struct fields:
- `seed int64`
- `scale float64` (default: 1.0/64.0 — noise frequency, same as current StandardGenerator)
- `baseHeight int` (default: 64 — target surface level, raised from current 32 to give more underground space)
- `gradientStrength float64` (default: 32.0 — how quickly density changes with altitude)
- `octaves int` (default: 4)
- `persistence float64` (default: 0.5)
- `lacunarity float64` (default: 2.0)

Constructor: `NewDensityGenerator(seed int64) TerrainGenerator`

Method `computeDensity(worldX, worldY, worldZ int) float64`:
- Convert world coords to noise space: `nx = float64(worldX) * g.scale`, same for ny, nz
- Sample octave noise: `noiseValue = octaveNoise3D(nx, ny, nz, g.seed, g.octaves, g.persistence, g.lacunarity)`
- Normalize from [0,1] to [-1,1]: `noiseValue = noiseValue*2.0 - 1.0`
- Compute height gradient: `heightGradient = (float64(g.baseHeight) - float64(worldY)) / g.gradientStrength`
- Return `noiseValue + heightGradient`
- Positive density = solid block, negative/zero = air

Method `PopulateChunk(c *Chunk)`:
- Triple nested loop over local coords (lx, lz, then ly — same outer loop order as current StandardGenerator)
- Convert to world coords: `worldX = c.X*ChunkSizeX + lx`, etc.
- Compute density. If density > 0: place block
- Block type selection:
  - worldY == 0: BlockTypeBedrock
  - Otherwise: BlockTypeStone (defer grass/dirt surface detection to Phase 2 per research recommendation)
- Set `c.dirty = true` at end

Method `HeightAt(worldX, worldZ int) int`:
- This is needed by ChunkStreamer to determine how many vertical chunks to generate per column.
- For 3D density, estimate the maximum height where terrain could exist.
- Sample the density at several Y values for this (x,z) column to find the highest solid block.
- Start from a generous max (baseHeight + gradientStrength*2 = ~128) and scan downward by steps of 4 until density > 0, then scan up block-by-block from there.
- If no solid found, return baseHeight as fallback.
- This doesn't need to be perfectly accurate — it determines chunk generation range, not rendering. Overestimating is safe (generates extra air chunks), underestimating misses terrain.
- A simpler approach: return `g.baseHeight + int(g.gradientStrength)` as a constant upper bound. This is safe because the height gradient ensures density is always negative above `baseHeight + gradientStrength` (since noise max is 1.0 and gradient = (baseHeight-y)/gradientStrength, so density = 1.0 + (baseHeight-y)/gradientStrength < 0 when y > baseHeight+gradientStrength). Use this simpler constant approach.

**Step B: Update `internal/world/world.go`**

Change line 37 from `gen := NewGenerator(1337)` to `gen := NewDensityGenerator(1337)`.

That's it — the interface is the same, so all other world.go code works unchanged.

**Step C: Update `internal/world/chunk_streamer.go`**

The ChunkStreamer already uses `HeightAt` correctly via the interface. No changes needed IF the DensityGenerator's `HeightAt` returns a reasonable value.

However, review the `enqueueColumn` method: it currently uses `HeightAt` at the column center (ChunkSizeX/2, ChunkSizeZ/2). With 3D density, the max height can vary across a chunk column. The constant upper-bound approach from Step A handles this — it returns the theoretical maximum terrain height regardless of x,z position, so all relevant chunks get generated.

No code changes needed in chunk_streamer.go — the interface contract is preserved.

**Step D: Verify session.go spawn**

`session.go` line 82 calls `gameWorld.SurfaceHeightAt(spawnX, spawnZ)` which calls `gen.HeightAt(x,z)`. With the constant upper-bound approach, this will return ~96 (baseHeight 64 + gradientStrength 32), which means the player spawns at y=98. This is likely above the actual surface, so the player will fall to the ground (physics handles this). This is acceptable for Phase 1. If it's too high, a refinement can scan downward at spawn position — but defer this unless it causes issues.

IMPORTANT: Keep `StandardGenerator` and `FlatGenerator` in generator.go — do NOT delete them. They are used in tests and may be useful for debug/creative mode later.
  </action>
  <verify>
Run `go build ./...` to verify full project compilation. Run `go vet ./...` for correctness. Run `go test ./internal/world/...` to ensure existing tests still pass (FlatGenerator tests should be unaffected). Then run the game with `go run ./cmd/mini-mc/` and verify:
1. The game starts without panic
2. Terrain is visible (not all air or all solid)
3. Terrain has varied elevation (not flat)
4. Walking around generates new chunks without crashes
  </verify>
  <done>DensityGenerator exists in density.go, implements TerrainGenerator interface. World uses DensityGenerator. Game compiles and runs. Existing tests pass. Terrain generates with 3D density (visible overhangs/variation expected but not required to verify at this stage — Plan 02 handles visual verification).</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds with no errors
2. `go vet ./...` reports no issues
3. `go test ./internal/world/...` passes all existing tests
4. Game runs without panics: `go run ./cmd/mini-mc/`
5. Terrain is visible and has varied height
6. No chunk boundary seams visible at x=16n, z=16n borders
</verification>

<success_criteria>
- 3D density-based terrain generation replaces heightmap as default generator
- Terrain shows vertical variation (not flat planes)
- Existing FlatGenerator and StandardGenerator preserved and testable
- All existing tests pass
- Game starts, generates terrain, and maintains interactive frame rate
</success_criteria>

<output>
After completion, create `.planning/phases/01-3d-terrain-foundation/01-01-SUMMARY.md`
</output>
